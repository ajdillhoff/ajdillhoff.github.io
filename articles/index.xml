<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Articles on Alex Dillhoff</title>
    <link>http://localhost:1313/articles/</link>
    <description>Recent content in Articles on Alex Dillhoff</description>
    <generator>Source Themes academia (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <copyright>Copyright &amp;copy; {year}</copyright>
    <lastBuildDate>Thu, 10 Oct 2024 00:00:00 -0500</lastBuildDate>
    
	    <atom:link href="http://localhost:1313/articles/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Using RAG to Talk to Your Data</title>
      <link>http://localhost:1313/articles/using-rag-to-talk-to-your-data/</link>
      <pubDate>Thu, 10 Oct 2024 00:00:00 -0500</pubDate>
      
      <guid>http://localhost:1313/articles/using-rag-to-talk-to-your-data/</guid>
      <description>&lt;div class=&#34;ox-hugo-toc toc&#34;&gt;
&lt;div class=&#34;heading&#34;&gt;Table of Contents&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#foundations-of-nlp&#34;&gt;Foundations of NLP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#architecture-of-language-models&#34;&gt;Architecture of Language Models&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#advanced-concepts-in-llms&#34;&gt;Advanced Concepts in LLMs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#retrieval-augmented-generation&#34;&gt;Retrieval Augmented Generation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!--endtoc--&gt;
&lt;p&gt;Large Language Models (LLMs) are a powerful tool for generating text. They are used to help us study, code, come up with new recipes, and more. However, they are prone to hallucinations; they can generate text that is not factual or relevant to the prompt. Retrieval Augmented Generation (RAG) is a technique that can address this issue by retrieving factual information from external databases. In this article, I will review the main concepts of LLMs and introduce RAG as a way to generate responses based on your own private data.&lt;/p&gt;
&lt;h2 id=&#34;foundations-of-nlp&#34;&gt;Foundations of NLP&lt;/h2&gt;
&lt;p&gt;How do machines &lt;em&gt;understand&lt;/em&gt; text? They surely do not understand language in the same way that we do, but they seem to do a pretty convincing job at generating useful output. Focusing on this question will be the theme of this brief overview of Natural Language Processing (NLP), specifically related to Large Language Models.&lt;/p&gt;
&lt;h3 id=&#34;tokenization&#34;&gt;Tokenization&lt;/h3&gt;
&lt;p&gt;Tokenization is the process of transforming input text into smaller chunks called &lt;strong&gt;tokens&lt;/strong&gt;. These tokens can be characters, words, phrases, or even whole sentences. The tokens themselves are then represented as numbers in a dictionary. This allows models to move back and forth between the actual text and the tokens they read and generate.&lt;/p&gt;
&lt;h4 id=&#34;types-of-tokens&#34;&gt;Types of Tokens&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Word Tokenization:&lt;/strong&gt; Divides text into individual words. It is commonly used for tasks like text classification or sentiment analysis.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sentence Tokenization:&lt;/strong&gt; Splits text into sentences, useful for analyzing document structure.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Subword Tokenization:&lt;/strong&gt; Breaks words into smaller units like prefixes or suffixes, which is helpful for handling out-of-vocabulary words.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Character Tokenization:&lt;/strong&gt; Segments text into individual characters, beneficial for languages without clear word boundaries.&lt;/li&gt;
&lt;/ul&gt;






&lt;figure&gt;

&lt;img src=&#34;http://localhost:1313/ox-hugo/2024-10-10_16-07-49_screenshot.png&#34; alt=&#34;&amp;lt;span class=&amp;#34;figure-number&amp;#34;&amp;gt;Figure 1: &amp;lt;/span&amp;gt;An example of tokenization using the tokenizer used in gpt-4o.&#34; &gt;



&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  
  &lt;p&gt;
    &lt;span class=&#34;figure-number&#34;&gt;Figure 1: &lt;/span&gt;An example of tokenization using the tokenizer used in gpt-4o.
    
    
    
  &lt;/p&gt; 
&lt;/figcaption&gt;

&lt;/figure&gt;

&lt;p&gt;Tokenizers are trained on a large corpus of data. Frequent subwords or character pairs are identified and merged to create unique tokens. The result is a vocabulary that is tailored for that specific corpus of data, implying that the selection of input documents for training is crucial. For example, a tokenizer trained on legal documents may not be the most efficient choice for a model that works primarily with medical documents.&lt;/p&gt;
&lt;p&gt;The choice of tokenizer is dependent on more than just the task. There are also language considerations. For a live demonstration of tokenization, check out &lt;a href=&#34;https://tiktokenizer.vercel.app/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;tiktokenizer&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;embeddings&#34;&gt;Embeddings&lt;/h3&gt;
&lt;p&gt;With a tokenizer at hand, the next step is to analyze the tokens and learn from them. Specifically, relationships between the tokens are learned through &lt;strong&gt;embeddings&lt;/strong&gt;. Embeddings are numerical representations of tokens that capture the semantic meaning of the text. They are essential for training models to understand and generate text.&lt;/p&gt;
&lt;p&gt;Embeddings are learned during the training process of a model, where the model aims to capture the semantic relationships and contextual nuances of tokens. For those familiar with gradient descent, embeddings are optimized to minimize the loss function of the model. This loss function effectively drives the model to learn the best possible embeddings for the task at hand.&lt;/p&gt;
&lt;p&gt;Once the embeddings are learned, the embedding layer can then be used to transform our input into a high-dimensional vector space in which the model can operate. This further allows the model to make predictions based on the relationships between the tokens.&lt;/p&gt;
&lt;h2 id=&#34;architecture-of-language-models&#34;&gt;Architecture of Language Models&lt;/h2&gt;
&lt;h3 id=&#34;encoders-and-decoders&#34;&gt;Encoders and Decoders&lt;/h3&gt;
&lt;p&gt;Language models consist of an encoder, a decoder, or sometimes both. The exact architecture is dependent on the task. Understand the roles that each one plays makes it easier to determine which model is best suited for a given task.&lt;/p&gt;
&lt;p&gt;An &lt;strong&gt;encoder&lt;/strong&gt; takes a sequence of input vectors based on the tokens and transforms them into fixed-length representations. Their primary goal is to extract relevant information from the input text. This information is then used in some downstream task such as classification or translation.&lt;/p&gt;






&lt;figure&gt;

&lt;img src=&#34;http://localhost:1313/ox-hugo/2024-10-10_17-10-09_screenshot.png&#34; alt=&#34;&amp;lt;span class=&amp;#34;figure-number&amp;#34;&amp;gt;Figure 2: &amp;lt;/span&amp;gt;A transformer-based encoder (&amp;lt;a href=&amp;#34;#citeproc_bib_item_5&amp;#34;&amp;gt;Vaswani et al. 2017&amp;lt;/a&amp;gt;).&#34; &gt;



&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  
  &lt;p&gt;
    &lt;span class=&#34;figure-number&#34;&gt;Figure 2: &lt;/span&gt;A transformer-based encoder (&lt;a href=&#34;#citeproc_bib_item_5&#34;&gt;Vaswani et al. 2017&lt;/a&gt;).
    
    
    
  &lt;/p&gt; 
&lt;/figcaption&gt;

&lt;/figure&gt;

&lt;p&gt;A &lt;strong&gt;decoder&lt;/strong&gt; takes the fixed length representation and generates an output sequence. Decoders are commonly used in tasks like machine translation or text generation. They take the information extracted by the encoder and use it to generate the desired output.&lt;/p&gt;
&lt;p&gt;The table below summarizes the roles of encoders and decoders in different tasks:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;Task&lt;/th&gt;
          &lt;th&gt;Encoder Role&lt;/th&gt;
          &lt;th&gt;Decoder Role&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Text Classification&lt;/td&gt;
          &lt;td&gt;Extracts relevant information from the input text.&lt;/td&gt;
          &lt;td&gt;N/A&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Machine Translation&lt;/td&gt;
          &lt;td&gt;Transforms the input text into a fixed-length representation.&lt;/td&gt;
          &lt;td&gt;Generates the output sequence based on the fixed-length representation.&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Text Generation&lt;/td&gt;
          &lt;td&gt;N/A&lt;/td&gt;
          &lt;td&gt;Generates the output sequence based on the input text.&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;transformers&#34;&gt;Transformers&lt;/h3&gt;
&lt;p&gt;Transformers are a type of neural network architecture that has revolutionized NLP tasks. They are based on the concept of attention mechanisms, which allow the model to focus on different parts of the input text when making predictions. This attention mechanism is what enables transformers to capture long-range dependencies in text, making them particularly effective for tasks like machine translation and text generation (&lt;a href=&#34;#citeproc_bib_item_5&#34;&gt;Vaswani et al. 2017&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Attention mechanisms produce relationships between sequences. When we look at an image of a dog running in a field with the intent of figuring out what the dog is doing in the picture, we pay greater attention to the dog and look at contextual cues in the image that might inform us of their task. This is an automatic process which allows us to efficiently process information.&lt;/p&gt;
&lt;p&gt;Attention mechanisms follow the same concept. Consider a machine translation task in which a sentence in English is translated to French. Certain words between the input and output will have stronger correlations than others (&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Bahdanau, Cho, and Bengio 2016&lt;/a&gt;).&lt;/p&gt;
&lt;h3 id=&#34;training-large-language-models&#34;&gt;Training Large Language Models&lt;/h3&gt;
&lt;p&gt;Since the main focus of this workshop is on Retrieval Augmented Generation, we will focus specifically on decoder-only LLMs like ChatGPT and Claude. These models are trained using a self-supervised learning approach, where the model learns to predict the next token in a sequence based on the previous tokens. This process is repeated over a large corpus of text data, allowing the model to learn the underlying patterns and relationships in the data (&lt;a href=&#34;#citeproc_bib_item_4&#34;&gt;Radford et al. 2018&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Training in this way allows the model to train on a virtually unlimited amount of data; the supervisory signals do not require human annotation. The more data the model is trained on, the better it can learn the underlying patterns in the data. This is why LLMs are typically trained on massive datasets like the Common Crawl or Wikipedia.&lt;/p&gt;
&lt;h2 id=&#34;advanced-concepts-in-llms&#34;&gt;Advanced Concepts in LLMs&lt;/h2&gt;
&lt;p&gt;After an LLM is trained, it can be used for many downstream tasks including chat, translation, summarization, and more. However, to make the most of these models, it is essential to understand some advanced concepts in LLMs.&lt;/p&gt;
&lt;h3 id=&#34;context-length&#34;&gt;Context Length&lt;/h3&gt;
&lt;p&gt;The context length of a model refers to the number of tokens that the model can consider when making predictions. This is an important factor in determining the performance of the model on different tasks. A model with a longer context length can capture more information about the input text, allowing it to make more accurate predictions. However, longer context lengths also require more computational resources, making them slower and more expensive to train.&lt;/p&gt;
&lt;h3 id=&#34;fine-tuning&#34;&gt;Fine-tuning&lt;/h3&gt;
&lt;p&gt;Fine-tuning is the process of taking a pre-trained model and training it on a smaller dataset for a specific task. This allows the model to adapt to the specific patterns in the data and improve its performance on the task. Fine-tuning is essential for achieving state-of-the-art performance on many NLP tasks. Consider a law firm that has a large corpus of legal documents. These documents will surely contain legal jargon and specific patterns that are not present in the general text data used to train the model. Fine-tuning the pre-trained model results in a model that is better suited for the legal domain while still benefiting from the general knowledge learned during pre-training.&lt;/p&gt;
&lt;p&gt;This is not always a direct upgrade from the original model. Depending on the quality of the dataset, the resulting model may perform worse than it did originally. There are also risks related to data privacy. If the dataset contains confidential information, the LLM may inadvertently memorize this information during fine-tuning.&lt;/p&gt;
&lt;p&gt;While fine-tuning may increase the performance on general tasks related to the new domain, it still does not solve the issue of context-specific data. This is where retrieval augmented generation comes into play.&lt;/p&gt;
&lt;h3 id=&#34;chat-models&#34;&gt;Chat Models&lt;/h3&gt;






&lt;figure&gt;

&lt;img src=&#34;http://localhost:1313/ox-hugo/2024-10-11_14-06-35_screenshot.png&#34; alt=&#34;&amp;lt;span class=&amp;#34;figure-number&amp;#34;&amp;gt;Figure 3: &amp;lt;/span&amp;gt;From Andrej Karpathy&amp;#39;s [State of GPT](&amp;lt;https://www.youtube.com/watch?v=bZQun8Y4L2A&amp;gt;) keynote.&#34; &gt;



&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  
  &lt;p&gt;
    &lt;span class=&#34;figure-number&#34;&gt;Figure 3: &lt;/span&gt;From Andrej Karpathy&amp;rsquo;s &lt;a href=&#34;https://www.youtube.com/watch?v=bZQun8Y4L2A&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;State of GPT&lt;/a&gt; keynote.
    
    
    
  &lt;/p&gt; 
&lt;/figcaption&gt;

&lt;/figure&gt;

&lt;p&gt;To create a chat model, a pre-trained LLM must be meticulously fine-tuned to behave as a chatbot. This involes three additional steps on top of the original model. This is summarized in the figure above.&lt;/p&gt;
&lt;h4 id=&#34;supervised-fine-tuning&#34;&gt;Supervised Fine-tuning&lt;/h4&gt;
&lt;p&gt;The first step is supervised fine-tuning. This involves created a specialized dataset that demonstrates the desired behavior of the chatbot. These samples must be vetted by human annotators to ensure quality. This process is not necessarily training the model to give the most accurate responses, but rather to give the most human-like responses.&lt;/p&gt;
&lt;h4 id=&#34;reward-modeling&#34;&gt;Reward Modeling&lt;/h4&gt;
&lt;p&gt;To optimize the quality of the model&amp;rsquo;s reponses, we need some way to tell the model what a quality response looks like. In this step, another specialized dataset is created based on a prompt and a number of different responses. A human annotator then assigns a ranking to these responses. This ranking is used as a reward signal for the model to optimize.&lt;/p&gt;
&lt;p&gt;The reward model itself is then trained to predict the ranking of the responses based on the human annotations. Once trained, the reward model is used to provide feedback to the chat model during training.&lt;/p&gt;
&lt;h4 id=&#34;reinforcement-learning&#34;&gt;Reinforcement Learning&lt;/h4&gt;
&lt;p&gt;With a trained reward model, the final stage of training is performed. Given an SFT model and the reward model, reinforcement learning is used to optimize the chat model. A prompt is given to the SFT model, which generates a response. This response is then ranked by the reward model, and the chat model is updated based on the reward signal.&lt;/p&gt;
&lt;h3 id=&#34;emergent-capabilities&#34;&gt;Emergent Capabilities&lt;/h3&gt;
&lt;p&gt;As it turns out, a model that was pre-trained on a large corpus of text data can be used for more than just generating text. It can also perform downstream tasks like question-answering without explicitly being trained on that task. This is known as &lt;strong&gt;zero-shot&lt;/strong&gt;, or &lt;strong&gt;few-shot&lt;/strong&gt;, learning (&lt;a href=&#34;#citeproc_bib_item_2&#34;&gt;Brown et al. 2020&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Given an input prompt, a pre-trained LLM will generate text that is relevant to the text contained within the prompt itself. If the prompt contains specialized context for a specific task, the generated text will also be relevant to that task. For example, provided an example of the task within the context before adding a novel prompt, the model will generate text that is relevant to the task.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example from (&lt;a href=&#34;#citeproc_bib_item_2&#34;&gt;Brown et al. 2020&lt;/a&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-nil&#34; data-lang=&#34;nil&#34;&gt;Alice was friends with Bob. Alice went to visit her friend ______. -&amp;gt; Bob
George bought some baseball equipment, a ball, a glove, and a _____. -&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;retrieval-augmented-generation&#34;&gt;Retrieval Augmented Generation&lt;/h2&gt;
&lt;p&gt;If you have used an LLM such as ChatGPT, Claude, or Gemini, you will have noticed that the responses are not always accurate. This is because the model is generating responses based on the input prompt alone. It does not have access to external information that could help it generate more accurate responses. Recent iterations of these popular models are now incorporating retrieval mechanisms to address this issue.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Retrieval Augmented Generation&lt;/strong&gt; (RAG) is a technique that retrieves relevent document chunks from external databases that are relevant to the original prompt. These chunks are compared to the context of the prompt primarily through semantic similarity, but other methods can be used as well. The model then generates a response based on the retrieved information. The benefit to this approach is that the model can generate responses that are not only factual, but based on your own private data without requiring any fine-tuning processes.&lt;/p&gt;






&lt;figure&gt;

&lt;img src=&#34;http://localhost:1313/ox-hugo/2024-10-11_14-40-07_screenshot.png&#34; alt=&#34;&amp;lt;span class=&amp;#34;figure-number&amp;#34;&amp;gt;Figure 4: &amp;lt;/span&amp;gt;Overview of RAG (&amp;lt;a href=&amp;#34;#citeproc_bib_item_3&amp;#34;&amp;gt;Gao et al. 2024&amp;lt;/a&amp;gt;).&#34; &gt;



&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  
  &lt;p&gt;
    &lt;span class=&#34;figure-number&#34;&gt;Figure 4: &lt;/span&gt;Overview of RAG (&lt;a href=&#34;#citeproc_bib_item_3&#34;&gt;Gao et al. 2024&lt;/a&gt;).
    
    
    
  &lt;/p&gt; 
&lt;/figcaption&gt;

&lt;/figure&gt;

&lt;p&gt;The basic process is conceptually simple:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Given a prompt, relevant document chunks are &lt;strong&gt;retrieved&lt;/strong&gt; from a database.&lt;/li&gt;
&lt;li&gt;The retrieved context is used to &lt;strong&gt;augment&lt;/strong&gt; the original prompt.&lt;/li&gt;
&lt;li&gt;The model &lt;strong&gt;generates&lt;/strong&gt; a response based on the augmented prompt.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RAG is an open research area with many potential applications. It is particularly useful in situations where the model needs to generate responses based on specific information that is not present in the training data. For example, a legal chatbot could use RAG to retrieve relevant legal documents to generate responses to legal questions. It can certainly be tricky to implement, but the benefits are clear.&lt;/p&gt;
&lt;p&gt;The rest of this article will take a more hands-on approach. See the &lt;a href=&#34;https://github.com/ajdillhoff/langchain-llama3.2-rag&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;accompanying repository&lt;/a&gt; for a practical demonstration of how to use RAG to talk to your data.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;style&gt;.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}&lt;/style&gt;&lt;div class=&#34;csl-bib-body&#34;&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_1&#34;&gt;&lt;/a&gt;Bahdanau, Dzmitry, Kyunghyun Cho, and Yoshua Bengio. 2016. ‚ÄúNeural Machine Translation by Jointly Learning to Align and Translate.‚Äù &lt;i&gt;Arxiv:1409.0473 [Cs, Stat]&lt;/i&gt;, May. &lt;a href=&#34;http://arxiv.org/abs/1409.0473&#34;&gt;http://arxiv.org/abs/1409.0473&lt;/a&gt;.&lt;/div&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_2&#34;&gt;&lt;/a&gt;Brown, Tom B., Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, et al. 2020. ‚ÄúLanguage Models Are Few-Shot Learners.‚Äù arXiv. &lt;a href=&#34;https://doi.org/10.48550/arXiv.2005.14165&#34;&gt;https://doi.org/10.48550/arXiv.2005.14165&lt;/a&gt;.&lt;/div&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_3&#34;&gt;&lt;/a&gt;Gao, Yunfan, Yun Xiong, Xinyu Gao, Kangxiang Jia, Jinliu Pan, Yuxi Bi, Yi Dai, Jiawei Sun, Meng Wang, and Haofen Wang. 2024. ‚ÄúRetrieval-Augmented Generation for Large Language Models: A Survey.‚Äù arXiv. &lt;a href=&#34;http://arxiv.org/abs/2312.10997&#34;&gt;http://arxiv.org/abs/2312.10997&lt;/a&gt;.&lt;/div&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_4&#34;&gt;&lt;/a&gt;Radford, Alec, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever. 2018. ‚ÄúImproving Language Understanding by Generative Pre-Training,‚Äù 12.&lt;/div&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_5&#34;&gt;&lt;/a&gt;Vaswani, Ashish, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, ≈Åukasz Kaiser, and Illia Polosukhin. 2017. ‚ÄúAttention Is All You Need,‚Äù 11.&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>The Language of LLMs</title>
      <link>http://localhost:1313/articles/the-language-of-llms/</link>
      <pubDate>Thu, 11 Apr 2024 00:00:00 -0500</pubDate>
      
      <guid>http://localhost:1313/articles/the-language-of-llms/</guid>
      <description>&lt;p&gt;The accompanying Colab notebook is &lt;a href=&#34;https://colab.research.google.com/drive/1Ch5wCSkYxXU6AAntrWH731Qk4-oE2c1P?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;available here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Large Language Models like ChatGPT have rapidly become ubiquitous tools that enhance productivity, creativity, and even decision-making processes across various domains. Their ability to generate human-like text, comprehend complex instructions, and provide informative responses has captivated the imagination of users worldwide. This paragraph was generated by an LLM (and edited by me).&lt;/p&gt;
&lt;p&gt;This workshop is for those that are curious as to how these models &lt;strong&gt;interpret&lt;/strong&gt; the input. By the end of this hour, you will hopefully be able to answer the following questions, among others:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How do Large Language Models &lt;strong&gt;read&lt;/strong&gt; and process text?&lt;/li&gt;
&lt;li&gt;Why are LLMs good at complex tasks, but seem to perform poorly on seemingly simple tasks like spelling or arithmetic?&lt;/li&gt;
&lt;li&gt;How does an LLM understand what it is processing?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;agenda&#34;&gt;Agenda&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Tokenization&lt;/li&gt;
&lt;li&gt;Unicode byte encodings&lt;/li&gt;
&lt;li&gt;Byte Pair Encoding (BPE)&lt;/li&gt;
&lt;li&gt;Embeddings&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;tokenization&#34;&gt;Tokenization&lt;/h2&gt;
&lt;p&gt;Tokenization is the process of transforming a sequence of characters into a sequence of tokens. A token is a unit of text that we treat as a single entity. For example, in English, a token could be a word, a sentence, or a paragraph. In programming languages, a token could be a variable name, a keyword, or a string.&lt;/p&gt;
&lt;p&gt;Before we get started, let&amp;rsquo;s check out a &lt;a href=&#34;https://tiktokenizer.vercel.app&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;live demonstration of tokenization.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Consider the input prompt below. &lt;em&gt;It isn&amp;rsquo;t likely that you would have mixed emoji and code in a single text file, but it serves as a good example for tokenization.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Why does my code üí• with a segmentation fault?
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;int main() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    int *arr = NULL;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    scanf(&amp;#34;%d&amp;#34;, arr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;At the most basic level, how is this text represented in a computer?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;These characters are represented as encodings such as ASCII or Unicode. For the purposes of the rest of this article, we will assume the input is represented using Unicode.&lt;/p&gt;
&lt;h3 id=&#34;unicode-byte-encodings&#34;&gt;Unicode Byte Encodings&lt;/h3&gt;
&lt;p&gt;If we were to print out the unicode values of the prompt above, we would get the following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[10, 87, 104, 121, 32, 100, 111, 101, 115, 32, 109, 121, 32, 99, 111, 100, 101, 32, 128165, ...]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Most of the values displayed in the previous cell are the same for ASCII. The emoji value has a very large number and can easily be spotted in the list.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Is that it? Is this how the input is fed into the model?&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This encoding is done at the character-level. What other types of encodings are there?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Character encoding&lt;/li&gt;
&lt;li&gt;Word encoding&lt;/li&gt;
&lt;li&gt;Sub-word encoding&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;What is the difference between them? Why would we pick one over another?&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;character-encoding&#34;&gt;Character Encoding&lt;/h3&gt;
&lt;p&gt;Character encoding converts each character into a unique integer. This is by far the simplest form of tokenization and has the benefit of a compact vocabulary. However, it is not able to effectively compress any common subsequences in the input. This leads to much larger sequences and longer training times.&lt;/p&gt;
&lt;p&gt;The biggest downside to this approach is that the individual characters are not very informative on a semantic level. For example, the word &amp;ldquo;cat&amp;rdquo; would be represented as three separate tokens, &amp;lsquo;c&amp;rsquo;, &amp;lsquo;a&amp;rsquo;, and &amp;rsquo;t&amp;rsquo;. If someone were to present you a single letter without context, you probably would likely not be able to understand the point of the message.&lt;/p&gt;
&lt;h3 id=&#34;word-encoding&#34;&gt;Word Encoding&lt;/h3&gt;
&lt;p&gt;Word encoding is a step up from character encoding. This encoding directly captures the semantic meaning of words and is a fine choice for text classification and sentiment analysis. The sequences formed are much shorter since every word can be converted into a unique token.&lt;/p&gt;
&lt;p&gt;The vocabulary size is very large since individual tokens cannot be broken down or recombined in new contexts. It also struggles with out-of-vocabulary words, since there are no base tokens to build upon.&lt;/p&gt;
&lt;h3 id=&#34;sub-word-encoding&#34;&gt;Sub-word Encoding&lt;/h3&gt;
&lt;p&gt;Sub-word encoding is a compromise between character and word encoding. It is able to capture the semantic meaning of words and can be broken down into smaller tokens. This allows for the model to generalize better to unseen words and phrases. Most large language models use sub-word encoding.&lt;/p&gt;
&lt;h2 id=&#34;byte-pair-encoding--bpe&#34;&gt;Byte Pair Encoding (BPE)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Byte_pair_encoding&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Byte Pair Encoding&lt;/a&gt; is a sub-word encoding technique that was originally designed for data compression. It is a simple algorithm that iteratively merges the most frequent pair of bytes in a sequence. This process is repeated until a predefined vocabulary size is reached.&lt;/p&gt;
&lt;p&gt;The algorithm is as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Initialize the vocabulary with all the characters in the input.&lt;/li&gt;
&lt;li&gt;Count the frequency of all pairs of characters in the vocabulary.&lt;/li&gt;
&lt;li&gt;Merge the most frequent pair of characters.&lt;/li&gt;
&lt;li&gt;Update the vocabulary with the merged pair.&lt;/li&gt;
&lt;li&gt;Repeat steps 2-4 until the vocabulary size reaches a predefined limit.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;embeddings&#34;&gt;Embeddings&lt;/h2&gt;
&lt;p&gt;A word embedding is a learned representation of text in which semantically similar words are mapped to nearby points in the embedding space. Since they are represented as vectors, all vector operations can be applied to them. This allows for the model to learn relationships between words and phrases, quantify their similarities and differences, and encode higher-level context information.&lt;/p&gt;
&lt;p&gt;Embeddings can be learned independently or jointly with the model. For example, the Word2Vec model learns embeddings using an unsupervised approach. It predicts the context of a word given its surrounding words. The embeddings are then used as input to a downstream task (&lt;a href=&#34;#citeproc_bib_item_3&#34;&gt;Mikolov et al. 2013&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;LLMs typically train embeddings jointly with the model. This allows them to learn embeddings for sentences, paragraphs, or even whole documents.&lt;/p&gt;
&lt;h3 id=&#34;creating-an-embedding-layer&#34;&gt;Creating an embedding layer&lt;/h3&gt;
&lt;p&gt;We can use libraries such as PyTorch to create a learnable embedding layer. The code below creates an embedding layer that converts each individual token into a `1024` dimensional embedded layer.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; torch.nn &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; nn
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; torch
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;token_embedding &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nn&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Embedding(vocab_size, &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;prompt_embedded &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; token_embedding(torch&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;LongTensor(encode(prompt)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(prompt_embedded&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;shape)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;training-the-embeddings&#34;&gt;Training the embeddings&lt;/h3&gt;
&lt;p&gt;Our corpus of a single C file is far too small to learn anything meaningful. Learning an embedding space requires a lot data and compute power. We can instead look at pre-trained embeddings. Huggingface has a large collection of pre-trained models that can be used for a variety of tasks. The accompanying notebook uses embeddings from &lt;code&gt;SentenceTransformer&lt;/code&gt; to demonstrate how embeddings can be used in practice.&lt;/p&gt;
&lt;h2 id=&#34;sentence-embeddings&#34;&gt;Sentence Embeddings&lt;/h2&gt;
&lt;p&gt;To demonstrate the power of embeddings, we will close out the workshop by reviewing sentence embeddings. BERT (&lt;a href=&#34;#citeproc_bib_item_1&#34;&gt;Devlin et al. 2019&lt;/a&gt;) and RoBERTa (&lt;a href=&#34;#citeproc_bib_item_2&#34;&gt;Liu et al. 2019&lt;/a&gt;) are LLMs that perform tasks such as semantic textual similarity. They both require that whole sentences be input, resulting in a very expensive computation.&lt;/p&gt;
&lt;p&gt;Sentence-BERT proposed an architecture that would embed these into meaningful embeddings that could be easily compared with vector operations (&lt;a href=&#34;#citeproc_bib_item_4&#34;&gt;Reimers and Gurevych 2019&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;In the cells below, we will use Huggingface (huggingface.co) to download and use a pre-trained sentence transformer. This particular one was trained on &lt;strong&gt;&lt;strong&gt;1,170,060,424&lt;/strong&gt;&lt;/strong&gt; sentence pairs.&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;style&gt;.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}&lt;/style&gt;&lt;div class=&#34;csl-bib-body&#34;&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_1&#34;&gt;&lt;/a&gt;Devlin, Jacob, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2019. ‚ÄúBERT: Pre-Training of Deep Bidirectional Transformers for Language Understanding.‚Äù arXiv. &lt;a href=&#34;https://doi.org/10.48550/arXiv.1810.04805&#34;&gt;https://doi.org/10.48550/arXiv.1810.04805&lt;/a&gt;.&lt;/div&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_2&#34;&gt;&lt;/a&gt;Liu, Yinhan, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. 2019. ‚ÄúRoBERTa: A Robustly Optimized BERT Pretraining Approach.‚Äù arXiv. &lt;a href=&#34;https://doi.org/10.48550/arXiv.1907.11692&#34;&gt;https://doi.org/10.48550/arXiv.1907.11692&lt;/a&gt;.&lt;/div&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_3&#34;&gt;&lt;/a&gt;Mikolov, Tomas, Kai Chen, Greg Corrado, and Jeffrey Dean. 2013. ‚ÄúEfficient Estimation of Word Representations in Vector Space.‚Äù arXiv. &lt;a href=&#34;http://arxiv.org/abs/1301.3781&#34;&gt;http://arxiv.org/abs/1301.3781&lt;/a&gt;.&lt;/div&gt;
  &lt;div class=&#34;csl-entry&#34;&gt;&lt;a id=&#34;citeproc_bib_item_4&#34;&gt;&lt;/a&gt;Reimers, Nils, and Iryna Gurevych. 2019. ‚ÄúSentence-BERT: Sentence Embeddings Using Siamese BERT-Networks.‚Äù arXiv. &lt;a href=&#34;https://doi.org/10.48550/arXiv.1908.10084&#34;&gt;https://doi.org/10.48550/arXiv.1908.10084&lt;/a&gt;.&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>An Introduction to Hidden Markov Models for Gesture Recognition</title>
      <link>http://localhost:1313/articles/intro_to_hmms/</link>
      <pubDate>Sat, 15 Jul 2023 00:00:00 -0500</pubDate>
      
      <guid>http://localhost:1313/articles/intro_to_hmms/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Hidden Markov Models provide a way of modeling the dynamics of sequential information. They have been used for speech recognition, part-of-speech tagging, machine translation, handwriting recognition, and, as we will see in this article, gesture recognition.&lt;/p&gt;
&lt;p&gt;Consider a somewhat practical use-case: you are going to throw a party with a meticulously curated playlist. You would rather not let anyone have the remote as it might get lost, and letting anyone interrupt the playlist with their own selections may derail the entire event. However, you still want to give your guests the ability to control the volume and skip back and forth between tracks in the playlist. We will also assume that guests will use change tracks and control the volume responsibly.&lt;/p&gt;
&lt;p&gt;The solution to this problem is to implement a gesture recognition system to identify simple hand motions. In this case, we only have to model 4 separate gestures: VolumeUp, VolumeDown, PrevTrack, NextTrack. Since the motions are temporal in nature, we can model each gesture using Hidden Markov Models. First, we need to cover a bit of background on what a Hidden Markov Model actually is.&lt;/p&gt;
&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;First, introduce Markov Chains&lt;/li&gt;
&lt;li&gt;Then the Markov assumption&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;At the core of our problem, we want to model a distribution over a sequence of states. Consider a sequence of only 3 states \(p(x_1, x_2, x_3)\). The full computation of this can be done using the chain rule of probability:&lt;/p&gt;
&lt;p&gt;\[
p(x_1, x_2, x_3) = p(x_1) p(x_2 | x_1) p(x_3 | x_1, x_2).
\]&lt;/p&gt;
&lt;p&gt;If the random variables of our problem are not conditionally independent, the complexity of calculating this is exponential in the number of random variables.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;Markov&lt;/strong&gt; in Hidden Markov Models addresses this complexity. The &lt;strong&gt;Markov Assumption&lt;/strong&gt; states that the probability of an event at time \(t\) is conditioned &lt;em&gt;only&lt;/em&gt; on the previously observed event: \(p(x_t | x_{t-1})\). This is compactly represented with a graphical model, as seen in figure &lt;strong&gt;TODO&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TODO: Figure of basic Markov Chain&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;hidden&lt;/strong&gt; qualifier comes from the fact that the data we wish to model was generated from some underlying process that is not directly observable. A classic example for HMMs uses the weather. Imagine you had a log which had the number of water bottles a person had drank per day over the entire year. To make the problem slightly more difficult, the log entries were not associated with a date. It is reasonable to say that the amount of water a person drinks is influenced by how hot or cold it is on a particular day. So, the &lt;strong&gt;hidden state&lt;/strong&gt; in this case is the weather: hot or cold. We can model this with an HMM by establishing that the amount of water (&lt;strong&gt;observed state&lt;/strong&gt;) is conditioned on the weather (&lt;strong&gt;hidden state&lt;/strong&gt;). Figure &lt;strong&gt;TODO&lt;/strong&gt; shows this HMM graphically.&lt;/p&gt;






&lt;figure&gt;

&lt;img src=&#34;http://localhost:1313/ox-hugo/2023-07-20_19-12-54_screenshot.png&#34; alt=&#34;&amp;lt;span class=&amp;#34;figure-number&amp;#34;&amp;gt;Figure 1: &amp;lt;/span&amp;gt;An HMM with 4 states and 2 observation symbols (y_1) or (y_2).&#34; &gt;



&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  
  &lt;p&gt;
    &lt;span class=&#34;figure-number&#34;&gt;Figure 1: &lt;/span&gt;An HMM with 4 states and 2 observation symbols (y_1) or (y_2).
    
    
    
  &lt;/p&gt; 
&lt;/figcaption&gt;

&lt;/figure&gt;

&lt;p&gt;Formally, a Hidden Markov Model is defined by&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of hidden states \(N\).&lt;/li&gt;
&lt;li&gt;A transition probability matrix \(A \in \mathbb{R}^{N \times N}\), where \(a_{ij} = p(z_t = j | z_{t-1} = i)\).&lt;/li&gt;
&lt;li&gt;An observation symbol probability distribution \(B = \{b_j(k)\} = p(\mathbf{x}_t = k | z_t = j)\).&lt;/li&gt;
&lt;li&gt;An initial state distribution \(\pi_i = p(z_t = i)\).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The trainable parameters of our model are \(\lambda = (A, B, \pi)\).&lt;/p&gt;
&lt;h2 id=&#34;functions-of-an-hmm&#34;&gt;Functions of an HMM&lt;/h2&gt;
&lt;p&gt;Given the basic definition of what an HMM is, how can we train the parameters defined in \(\lambda\). If we somehow already knew the parameters, how can we extract useful information from the model? Depending on our task, we can use HMMs to answer many important questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Filtering&lt;/strong&gt; computes \(p(z_t | \mathbf{x}_{1:t})\). That is, we are computing this probability as new samples come in up to time \(t\).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Smoothing&lt;/strong&gt; is accomplished when we have all the data in the sequence.
This is expressed as \(p(z_t|\mathbf{x}_{1:T})\).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fixed lag smoothing&lt;/strong&gt; allows for a trade off between accuracy and delay. It is useful in cases where we might not have the full sequence, but we wish to compute \(p(z_{t-l}|\mathbf{x}_{1:t})\) for some \(l &amp;gt; 0\).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Predictions&lt;/strong&gt; are represented as \(p(z_{t+h}|\mathbf{x}_{1:t})\), where \(h &amp;gt; 0\).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MAP estimation&lt;/strong&gt; yields the most probably state sequence \(\text{arg}\max_{\mathbf{z}_{1:T}}p(\mathbf{z}_{1:T}|\mathbf{x}_{1:T})\).&lt;/li&gt;
&lt;li&gt;We can sample the &lt;strong&gt;posterior&lt;/strong&gt; \(p(\mathbf{z}_{1:T}|\mathbf{x}_{1:T})\).&lt;/li&gt;
&lt;li&gt;We can also compute \(p(\mathbf{x}_{1:T})\) by summing up over all hidden paths. This is useful for classification tasks.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course not all of these functions make sense for every possible task, more on that later. This article is not meant to be an exhaustive resource for all HMM functions; we will only look at the tasks necessary to train and use HMMs for isolated gesture recognition &lt;strong&gt;TODO: offer additional reading suggestions&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;data-processing&#34;&gt;Data Processing&lt;/h2&gt;
&lt;p&gt;As far as the efficacy of our model goes, how we process the data is the most important. Our system will start with a camera that records our guests performing one of the four simple motions. For simplicity, let&amp;rsquo;s pretend that the camera has an onboard chip that detects the 2D centroids of the left hand for each frame. That helps a lot, but there is still the problem of isolating a group of frames based on when the user wanted to start and finish the command. Assuming we have a solution for both of these problems, we still need to take into account that users will gesture at different speeds. Since all of these problems are challenging in their own right, we will assume the computer vision fairy has taken care of this for us.&lt;/p&gt;
&lt;p&gt;Each gesture in our dataset consists of 30 \((x, y)\) locations of the center of the left hand with respect to image coordinates. Even with this simplified data, we have another problem: different users may gesture from different locations. The hand locations for one user performing the &lt;code&gt;VolumeUp&lt;/code&gt; gesture may be vastly different from another. This isn&amp;rsquo;t too bad to deal with. We could normalize or training data by subtracting the location of the hand in the first frame from the gesture. That way every input would start at \((0, 0)\). We can simplify this even further by using &lt;strong&gt;relative motion states&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;relative-motion-states&#34;&gt;Relative Motion States&lt;/h3&gt;
&lt;p&gt;Relative motion states discretize our data, thus simplifying the input space. The idea is quite simple: if the hand moved to the right relative to the previous frame, we assign \(x = 1\) for that frame. If it moved to the left, assign \(x = -1\). If it didn&amp;rsquo;t move at all, or did not move a significant amount, assign \(x = 0\). We apply similar rules for the \(y\) locations as well. The &lt;strong&gt;TODO: figure&lt;/strong&gt; below shows the relative motion grid.&lt;/p&gt;
&lt;p&gt;Besides greatly simplifying our input space, meaning we can use a simple categorical distribution to model these observations, we no longer have to worry about the discrepency between where each user performed the gesture.&lt;/p&gt;
&lt;h2 id=&#34;modeling-a-gesture&#34;&gt;Modeling a Gesture&lt;/h2&gt;
&lt;p&gt;Our system will consist of 4 HMM models to model the dynamics of each gesture. To determine which gesture was performed, we will given our input sequence to each one and have it compute \(p(\mathbf{x}_{1:T}; \lambda_i)\), the probability of the observation given the parameters of model \(i\). Whichever model gives the high probability wins.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TODO&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Describe EM at a high level, show the breakdown of probabilities that need to be known&lt;/li&gt;
&lt;li&gt;Go into forward-backwards&lt;/li&gt;
&lt;li&gt;Go back to EM and plug them in&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;training-expectation-maximization&#34;&gt;Training: Expectation-Maximization&lt;/h3&gt;
&lt;p&gt;If we cannot observe the hidden states directly, how are we supposed to update the model parameters \(\lambda = (A, B, \pi)\)? We may not have all of the information, but we do have &lt;em&gt;some&lt;/em&gt; information. We can use that to fill in the missing values with what we would expect them to be given what we already know. Then, we can update our parameters using those expected values. This is accomplished through a two-stage algorithm called &lt;strong&gt;Expectation-Maximization&lt;/strong&gt;. Those familiar with k-Nearest Neighbors should already be familiar with this process.&lt;/p&gt;
&lt;h4 id=&#34;updating-with-perfect-information&#34;&gt;Updating with Perfect Information&lt;/h4&gt;
&lt;p&gt;It is useful to know how we would update our parameters assuming we had perfect information. If the hidden states were fully observable, then updating our model parameters would be as straightforward as computing the maximum likelihood estimates.
For \(A\) and \(\pi\), we first tally up the following counts:&lt;/p&gt;
&lt;p&gt;\[
\hat{a}_{ij} = \frac{N_{ij}}{\sum_j N_{ij}},
\]&lt;/p&gt;
&lt;p&gt;the number of times we expect to transition from \(i\) to \(j\) divided by the number of times we transition from \(i\) to any other state. Put simply, this computes the expected transitions from \(i\) to \(j\) normalized by all the times we expect to start in state \(i\).&lt;/p&gt;
&lt;p&gt;For \(\pi\), we have&lt;/p&gt;
&lt;p&gt;\[
\hat{\pi_i} = \frac{N_i}{\sum_i N_i},
\]&lt;/p&gt;
&lt;p&gt;the number of times we expect to start in state \(i\) divided by the number of times we start in any other state.&lt;/p&gt;
&lt;p&gt;Estimating the parameters for \(B\) depends on which distribution we are using for our observation probabilities.
For a multinomial distribution, we would compute the number of times we are in state \(j\) and observe a symbol \(k\) divided by the number of times we are in state \(j\):&lt;/p&gt;
&lt;p&gt;\[
\hat{b}_{jk} = \frac{N_{jk}}{N_k},
\]&lt;/p&gt;
&lt;p&gt;where&lt;/p&gt;
&lt;p&gt;\[
N_{jk} = \sum_{i=1}^N \sum_{t=1}^T \mathbb{1} (z_{i, t}=j, x_{i, t}=k).
\]&lt;/p&gt;
&lt;p&gt;It is also common to model our emission probability using a Normal distribution. We can even use a parameterized model like a neural network. &lt;strong&gt;TODO: provide links to examples of these&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;updating-with-missing-information&#34;&gt;Updating with Missing Information&lt;/h4&gt;
&lt;p&gt;Now to the real problem: fill in our missing information using our observable data and the current parameter estimates. There are two important statistics that we need to compute, called the &lt;strong&gt;sufficient statistics&lt;/strong&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The expected number of transitions from \(i\) to \(j\).&lt;/li&gt;
&lt;li&gt;The expected number of times we are transitioning from \(i\) to any other state.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Both of these can be computed starting with the same probability &lt;em&gt;conditioned&lt;/em&gt; on our observable data:&lt;/p&gt;
&lt;p&gt;\[
p(z_t = i, z_{t+1} = j|\mathbf{x}_{1:T}).
\]&lt;/p&gt;
&lt;h3 id=&#34;forwards-backwards-algorithm&#34;&gt;Forwards-Backwards Algorithm&lt;/h3&gt;
&lt;p&gt;Computing joint distribution can be very computationally expensive. Fortunately for us, the Markov assumption along with operations on graphs open the door to a dynamic programming approach named the Forward-Backward algorithm.&lt;/p&gt;
&lt;p&gt;The Forwards-Backwards Algorithm, also known as the &lt;a href=&#34;https://en.wikipedia.org/wiki/Baum%E2%80%93Welch_algorithm&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Baum-Welch algorithm&lt;/a&gt;, provides an effective solution to computing the joint described above. In fact, there are many useful distributions that can be computed with this algorithm such as the &lt;strong&gt;filtering&lt;/strong&gt; and &lt;strong&gt;smoothing&lt;/strong&gt; tasks.&lt;/p&gt;
&lt;h4 id=&#34;forward-probability&#34;&gt;Forward Probability&lt;/h4&gt;
&lt;p&gt;The forward probability, often denoted as \(\alpha\), represents the probability of ending up at a particular hidden state \(i\) at time \(t\) having seen the observations up to that time:&lt;/p&gt;
&lt;p&gt;\[
\alpha_t(i) = p(z_t = i, \mathbf{x}_{1:t} | \lambda).
\]&lt;/p&gt;
&lt;p&gt;This value is computed recursively starting from \(t=1\) and going forwards to \(t=T\).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Initialization&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For \(t=1\), we calculate:&lt;/p&gt;
&lt;p&gt;\[
\alpha_1(i) = \pi_i b_i(x_1),\quad 1 \leq i \leq N,
\]&lt;/p&gt;
&lt;p&gt;where \(\pi_i\) is the initial probability of state \(i\) and \(b_i(x_1)\) is the emission probability of the first observation \(x_1\) given that we are in state \(i\).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Recursion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;After that, we calculate the remaining \(\alpha_t(i)\) as follows:&lt;/p&gt;
&lt;p&gt;\[
\alpha_{t+1}(j) = b_j(x_{t+1}) \sum_{i=1}^{N} \alpha_{t}(i)a_{ij},
\]&lt;/p&gt;
&lt;p&gt;where \(N\) is the number of hidden states, and \(a_{ij}\) is the transition probability from state \(i\) to state \(j\).&lt;/p&gt;
&lt;h4 id=&#34;backward-probability&#34;&gt;Backward Probability&lt;/h4&gt;
&lt;p&gt;The backward probability, denoted as \(\beta\), gives the probability of observing the remaining observations from time \(t+1\) to \(T\) given that we are in state \(i\) at time \(t\):&lt;/p&gt;
&lt;p&gt;\[
\beta_t(i) = p(\mathbf{x}_{t+1:T} | z_t = i, \lambda).
\]&lt;/p&gt;
&lt;p&gt;Again, this is calculated recursively but this time starting from \(t=T\) and going backwards to \(t=1\).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Initialization&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For \(t=T\), we initialize:&lt;/p&gt;
&lt;p&gt;\[
\beta_T(i) = 1, \forall i.
\]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Recursion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Then we calculate the remaining \(\beta_t(i)\) as:&lt;/p&gt;
&lt;p&gt;\[
\beta_{t}(i) = \sum_{j=1}^{N} a_{ij}b_j(x_{t+1})\beta_{t+1}(j).
\]&lt;/p&gt;
&lt;h4 id=&#34;calculating-the-sufficient-statistics&#34;&gt;Calculating the Sufficient Statistics&lt;/h4&gt;
&lt;p&gt;With these two sets of probabilities, we can calculate the two required sufficient statistics as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The expected number of transitions from \(i\) to \(j\):&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;\[
\frac{\sum_{t=1}^{T-1} \alpha_t(i) a_{ij} b_j(x_{t+1}) \beta_{t+1}(j)}{P(X|\lambda)}
\]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The expected number of times we are transitioning from \(i\) to any other state:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;\[
\frac{\sum_{t=1}^{T-1} \alpha_t(i) \beta_t(i)}{P(X|\lambda)}
\]&lt;/p&gt;
&lt;p&gt;Where \(P(X|\lambda)\) is the total probability of the observations, calculated as:&lt;/p&gt;
&lt;p&gt;\[
P(X|\lambda) = \sum_{i=1}^{N} \alpha_T(i)
\]&lt;/p&gt;
&lt;h4 id=&#34;how-does-this-give-us-p--z-t-i-z-t-plus-1-j-mathbf-x-1-t&#34;&gt;How does this give us \(p(z_t = i, z_{t+1} = j|\mathbf{x}_{1:T})\)?&lt;/h4&gt;
&lt;p&gt;To understand how the variables of the Forwards-Backwards algorithm relate to the original probabilities, we can express the term \(p(z_t = i, z_{t+1} = j|\mathbf{x}_{1:T})\) in terms of the original probability distributions in the HMM:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\(\pi_i\) - the probability of starting in state \(i\),&lt;/li&gt;
&lt;li&gt;\(a_{ij}\) - the probability of transitioning from state \(i\) to state \(j\),&lt;/li&gt;
&lt;li&gt;\(b_j(x_t)\) - the probability that state \(j\) will emit observation \(x_t\).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The joint probability \(p(z_t = i, z_{t+1} = j, \mathbf{x}_{1:T})\) would represent the probability of being in state \(i\) at time \(t\), moving to state \(j\) at time \(t+1\), and observing the sequence of emissions \(\mathbf{x}_{1:T}\). This can be factored as follows due to the Markov property:&lt;/p&gt;
&lt;p&gt;\[
p(z_t = i, z_{t+1} = j, \mathbf{x}_{1:T}) = p(\mathbf{x}_{1:t}, z_t = i)p(z_{t+1} = j| z_t = i)p(\mathbf{x}_{t+1:T} | z_{t+1} = j, \mathbf{x}_{1:t}).
\]&lt;/p&gt;
&lt;p&gt;Using our definitions of \(\alpha\) and \(\beta\), we can rewrite this in terms of our HMM quantities:&lt;/p&gt;
&lt;p&gt;\[
p(z_t = i, z_{t+1} = j, \mathbf{x}_{1:T}) = \alpha_t(i)a_{ij}b_j(x_{t+1})\beta_{t+1}(j).
\]&lt;/p&gt;
&lt;p&gt;Here, \(\alpha_t(i)\) represents \(p(\mathbf{x}_{1:t}, z_t = i)\), the joint probability of the observations until time \(t\) and being in state \(i\) at time \(t\), and \(\beta_{t+1}(j)\) represents \(p(\mathbf{x}_{t+1:T} | z_{t+1} = j)\), the probability of the observations from time \(t+1\) to \(T\) given we&amp;rsquo;re in state \(j\) at time \(t+1\).&lt;/p&gt;
&lt;p&gt;Then, to obtain \(p(z_t = i, z_{t+1} = j|\mathbf{x}_{1:T})\), we divide by \(p(\mathbf{x}_{1:T})\) to normalize the probabilities, which is the sum over all states of \(\alpha_T(i)\), or equivalently, the sum over all states of \(\beta_1(i)\pi_i b_i(x_1)\).&lt;/p&gt;
&lt;p&gt;This gives us:&lt;/p&gt;
&lt;p&gt;\[
p(z_t = i, z_{t+1} = j|\mathbf{x}_{1:T}) = \frac{\alpha_t(i)a_{ij}b_j(x_{t+1})\beta_{t+1}(j)}{\sum_{i=1}^{N}\alpha_T(i)}.
\]&lt;/p&gt;
&lt;p&gt;This is the same expression as before, but broken down in terms of the original HMM quantities and the forward and backward variables. This can also be explained through graph properties and operations. See &lt;a href=&#34;https://cedar.buffalo.edu/~srihari/CSE574/Chap13/13.2.2-ForwardBackward.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Sargur Srihari&amp;rsquo;s excellent lecture slides&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h2 id=&#34;implementation-in-python&#34;&gt;Implementation in Python&lt;/h2&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
</description>
    </item>
    
  </channel>
</rss>
